<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LABIL‚ÄìSTABIL [AUDIO]</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #050808;
            overflow: hidden;
            cursor: none;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        canvas {
            display: block;
            touch-action: none;
        }

        /* INFO BUTTON */
        #infoButton {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            border: 1px solid #444;
            background: rgba(15, 15, 15, 0.9);
            color: #888;
            font-size: 20px;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto !important;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: all 0.2s;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        #infoButton:hover {
            border-color: #888;
            color: #ccc;
        }

        #infoButton:active {
            transform: scale(0.95);
        }

        @media (max-width: 767px) {
            #infoButton {
                width: 50px;
                height: 50px;
                font-size: 24px;
            }
        }

        /* INFO PANEL */
        #infoPanel {
            position: fixed;
            top: 70px;
            left: 20px;
            background: rgba(15, 15, 15, 0.95);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            pointer-events: auto !important;
            z-index: 9998;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 12px;
            line-height: 1.6;
            color: #ccc;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: opacity 0.2s, transform 0.2s, visibility 0.2s;
        }

        #infoPanel.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        #infoPanel .key {
            color: #ff4444;
            font-weight: 500;
        }

        #infoPanel br {
            line-height: 1.8;
        }

        @media (max-width: 767px) {
            #infoPanel {
                top: 80px;
            }
        }

        .desktop-only {
            display: block;
        }
        
        .mobile-only {
            display: none;
        }

        @media (max-width: 767px) {
            .desktop-only {
                display: none;
            }
            .mobile-only {
                display: block;
            }
        }

        /* SOUND BUTTON (MOBILE) */
        #soundButton {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 45px;
            height: 45px;
            border: 1px solid #666;
            background: rgba(10, 10, 10, 0.9);
            color: #fff;
            font-size: 18px;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto !important;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            z-index: 9999;
            touch-action: manipulation;
        }

        #soundButton:active {
            background: rgba(20, 20, 20, 0.9);
            transform: scale(0.9);
        }

        #soundButton.active {
            border-color: #ff4444;
            color: #ff4444;
        }

        /* Pulse animation for sound button on mobile (before audio init) */
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                border-color: #ff4444;
            }
            50% {
                transform: scale(1.1);
                border-color: #ff6666;
            }
        }

        #soundButton.needs-init {
            animation: pulse 2s ease-in-out infinite;
            border-color: #ff4444;
            color: #ff4444;
        }

        @media (min-width: 768px) {
            #soundButton {
                display: none;
            }
        }

        @media (max-width: 767px) {
            #soundButton {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- INFO BUTTON -->
    <button id="infoButton" aria-label="Info">‚ìò</button>

    <!-- INFO PANEL (hidden by default) -->
    <div id="infoPanel">
        <div class="desktop-only">
            <span class="key">+</span> / <span class="key">‚àí</span> &nbsp;&nbsp; Grid Dichte<br>
            <span class="key">DRAG</span> &nbsp;&nbsp; Verbindungen rei√üen<br>
            <span class="key">S</span> &nbsp;&nbsp; Sound toggle<br>
            <span class="key">R</span> &nbsp;&nbsp; Reset<br>
            <br>
            Grid: <span class="key" id="gridInfo">80px</span>
        </div>
        <div class="mobile-only">
            <span class="key">‚ô™</span> &nbsp;&nbsp; Antippen f√ºr Sound<br>
            <span class="key">ü§è</span> &nbsp;&nbsp; Pinch f√ºr Dichte<br>
            <span class="key">üëÜ</span> &nbsp;&nbsp; 1 Finger hovern<br>
            <span class="key">‚úåÔ∏è</span> &nbsp;&nbsp; 2 Finger rei√üen<br>
            <span class="key">üëÜüëÜüëÜ</span> &nbsp; 3√ó Tap reset<br>
            <br>
            Grid: <span class="key" id="gridInfoMobile">80px</span>
        </div>
    </div>

    <!-- SOUND BUTTON (MOBILE ONLY) -->
    <button id="soundButton" class="active" aria-label="Sound">‚ô™</button>

    <script>
        // SETUP UI BUTTONS IMMEDIATELY (before p5.js)
        document.addEventListener('DOMContentLoaded', function() {
            console.log("üöÄ DOM loaded, setting up buttons...");
            
            // Info button toggle
            const infoButton = document.getElementById('infoButton');
            const infoPanel = document.getElementById('infoPanel');
            
            if (infoButton && infoPanel) {
                infoButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    infoPanel.classList.toggle('visible');
                    console.log("‚ÑπÔ∏è Info panel toggled:", infoPanel.classList.contains('visible'));
                });
                
                infoButton.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    infoPanel.classList.toggle('visible');
                    console.log("‚ÑπÔ∏è Info panel toggled (touch):", infoPanel.classList.contains('visible'));
                });
            }

            // Sound button toggle AND audio unlock
            const soundButton = document.getElementById('soundButton');
            if (soundButton) {
                let isProcessing = false; // Prevent double-tap issues
                
                const handleSoundToggle = async function(e) {
                    if (isProcessing) {
                        console.log("‚ö†Ô∏è Already processing, ignoring duplicate event");
                        return;
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                    isProcessing = true;
                    
                    console.log("üîä Sound button tapped/clicked");
                    
                    // Initialize audio on first interaction (CRITICAL for iOS!)
                    if (!audioInitialized) {
                        console.log("üéµ First sound button tap - unlocking audio...");
                        
                        try {
                            // Direct Tone.start() call from button event
                            await Tone.start();
                            console.log("‚úÖ Tone.start() from button - state:", Tone.context.state);
                            
                            // Initialize our audio system
                            await initAudio();
                            console.log("üéâ Audio unlocked and initialized from sound button!");
                            
                            // Remove pulse animation if present
                            soundButton.classList.remove('needs-init');
                            
                            // Keep button active (sound is on)
                            soundEnabled = true;
                            soundButton.classList.add('active');
                            
                            // Visual feedback - quick scale animation
                            soundButton.style.transition = 'transform 0.2s';
                            soundButton.style.transform = 'scale(1.2)';
                            setTimeout(() => {
                                soundButton.style.transform = 'scale(1)';
                            }, 200);
                            
                        } catch (err) {
                            console.error("‚ùå Sound button audio init failed:", err);
                            console.error("Error details:", err.message, err.stack);
                            soundEnabled = false;
                            soundButton.classList.remove('active');
                            alert("Audio konnte nicht gestartet werden. Bitte nochmal versuchen.");
                        }
                    } else {
                        // Toggle sound if already initialized
                        soundEnabled = !soundEnabled;
                        soundButton.classList.toggle('active', soundEnabled);
                        console.log("üîä Sound toggled:", soundEnabled);
                    }
                    
                    setTimeout(() => { isProcessing = false; }, 500);
                };
                
                // Use touchend for mobile, click for desktop
                soundButton.addEventListener('touchend', handleSoundToggle);
                soundButton.addEventListener('click', handleSoundToggle);
                
                console.log("‚úÖ Sound button ready");
            }
            
            console.log("‚úÖ All buttons initialized");
        });
        
        // AUDIO SYSTEM
        let audioInitialized = false;
        let soundEnabled = true;
        let tearSynth, particleSynth, reverb;
        let audioUnlocked = false;
        
        async function initAudio() {
            if (audioInitialized) return;
            
            try {
                console.log("üéµ Attempting audio init...");
                console.log("Audio context state before:", Tone.context.state);
                
                await Tone.start();
                
                console.log("Audio context state after:", Tone.context.state);
                console.log("‚úÖ Tone.start() successful");
                
                // Create reverb first
                reverb = new Tone.Reverb({ decay: 4, wet: 0.4 }).toDestination();
                await reverb.ready;
                console.log("‚úÖ Reverb created");
                
                // Create synths
                tearSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.4 }
                }).connect(reverb);
                tearSynth.volume.value = -6;
                console.log("‚úÖ Tear synth created");
                
                particleSynth = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.005, decay: 0.2, sustain: 0, release: 0.3 }
                }).connect(reverb);
                particleSynth.volume.value = -8;
                console.log("‚úÖ Particle synth created");
                
                audioInitialized = true;
                audioUnlocked = true;
                
                // Test sound to "unlock" iOS audio
                particleSynth.triggerAttackRelease("C1", "32n");
                console.log("üîä Audio fully initialized and unlocked!");
                
            } catch (err) {
                console.error("‚ùå Audio initialization failed:", err);
            }
        }
        
        function updateAudio(strain, intensity, hasMovement) {
            // Not needed anymore - only particle and tear sounds
        }
        
        function playTearSound(intensity, x, y) {
            if (!audioInitialized) return;
            let baseNote = map(x, 0, width, 200, 600);
            tearSynth.triggerAttackRelease([
                Tone.Frequency(baseNote).toNote(),
                Tone.Frequency(baseNote * 0.75).toNote(),
                Tone.Frequency(baseNote * 0.5).toNote()
            ], "8n");
        }
        
        function playParticleSound(particle, intensity) {
            if (!audioInitialized || !soundEnabled) {
                return;
            }
            
            if (!particleSynth) {
                console.error("‚ùå Particle synth not initialized!");
                return;
            }
            
            try {
                // Ensure minimum intensity so slow movements still make sound
                let actualIntensity = max(intensity, 0.2);
                
                let baseFreq = 261.63; // C4
                let octaves = 0 + actualIntensity * 4; // 0 to 4 octaves = C4 to C8!
                let freq = baseFreq * Math.pow(2, octaves);
                let xVariation = map(particle.x, 0, width, 0.95, 1.05);
                freq *= xVariation;
                let note = Tone.Frequency(freq).toNote();
                
                particleSynth.triggerAttackRelease(note, "16n");
                
                // Only log occasionally to avoid spam
                if (frameCount % 30 === 0) {
                    console.log("üîä Playing particle sound:", note, "intensity:", actualIntensity.toFixed(2));
                }
            } catch (err) {
                console.error("‚ùå Error playing particle sound:", err);
            }
        }
        
        // VISUAL SYSTEM
        let gridSpacing = 80;
        let particles = [];
        let connections = [];
        let currentParticle = null;
        let lastParticleId = null;
        let isDragging = false;
        let prevMouseX = 0;
        let prevMouseY = 0;

        // GESTURE DETECTION
        let lastTouchDist = 0;
        let tapCount = 0;
        let lastTapTime = 0;
        let tapTimeout = null;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            frameRate(60);
            createGrid();
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            
            console.log("‚úÖ p5.js setup complete");
            
            // Add pulse animation to sound button on mobile if audio not init
            const isMobile = window.innerWidth < 768;
            if (isMobile) {
                const soundButton = document.getElementById('soundButton');
                if (soundButton && !audioInitialized) {
                    soundButton.classList.add('needs-init');
                    console.log("üì± Mobile detected - sound button pulsing");
                }
            }
        }

        function createGrid() {
            particles = [];
            connections = [];
            
            let cols = floor(width / gridSpacing) + 1;
            let rows = floor(height / gridSpacing) + 1;
            let offsetX = (width - (cols - 1) * gridSpacing) / 2;
            let offsetY = (height - (rows - 1) * gridSpacing) / 2;
            
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    let x = offsetX + i * gridSpacing;
                    let y = offsetY + j * gridSpacing;
                    let isEdge = (i === 0 || i === cols-1 || j === 0 || j === rows-1);
                    
                    particles.push({
                        x: x, y: y,
                        homeX: x, homeY: y,
                        vx: 0, vy: 0,
                        pinned: isEdge,
                        i: i, j: j,
                        size: 10,
                        id: i + '_' + j
                    });
                }
            }
            
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    let p1 = particles[i];
                    let p2 = particles[j];
                    if ((abs(p1.i - p2.i) === 1 && p1.j === p2.j) || 
                        (p1.i === p2.i && abs(p1.j - p2.j) === 1)) {
                        connections.push({
                            p1: p1, p2: p2,
                            length: dist(p1.homeX, p1.homeY, p2.homeX, p2.homeY),
                            active: true
                        });
                    }
                }
            }
            
            document.getElementById('gridInfo').textContent = gridSpacing + 'px';
            const mobileInfo = document.getElementById('gridInfoMobile');
            if (mobileInfo) mobileInfo.textContent = gridSpacing + 'px';
        }

        function draw() {
            background(10, 10, 10);
            
            let minDist = 999999;
            let nearest = null;
            for (let p of particles) {
                let d = dist(mouseX, mouseY, p.x, p.y);
                if (d < minDist) {
                    minDist = d;
                    nearest = p;
                }
            }
            
            let dx = mouseX - prevMouseX;
            let dy = mouseY - prevMouseY;
            let speed = sqrt(dx * dx + dy * dy);
            let intensity = constrain(speed / 20, 0, 1);
            
            if (nearest && (!currentParticle || minDist < dist(mouseX, mouseY, currentParticle.x, currentParticle.y))) {
                let oldParticle = currentParticle;
                currentParticle = nearest;
                
                // Play sound when particle changes OR when moving (not stationary)
                if (!oldParticle || oldParticle.id !== currentParticle.id) {
                    playParticleSound(currentParticle, intensity);
                } else if (speed > 1) {
                    // Throttle: only play every few frames when moving over same particle
                    if (frameCount % 3 === 0) {
                        playParticleSound(currentParticle, intensity);
                    }
                }
            }
            
            if (isDragging && (dx !== 0 || dy !== 0)) {
                for (let c of connections) {
                    if (!c.active) continue;
                    let intersect = lineIntersect(
                        prevMouseX, prevMouseY, mouseX, mouseY,
                        c.p1.x, c.p1.y, c.p2.x, c.p2.y
                    );
                    if (intersect && intensity > 0.2) {
                        c.active = false;
                        let midX = (c.p1.x + c.p2.x) / 2;
                        let midY = (c.p1.y + c.p2.y) / 2;
                        playTearSound(intensity, midX, midY);
                    }
                }
            }
            
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            let hasMovement = (dx !== 0 || dy !== 0) || isDragging;
            
            for (let p of particles) {
                if (p.pinned) {
                    p.x = p.homeX;
                    p.y = p.homeY;
                    p.vx = 0;
                    p.vy = 0;
                    continue;
                }
                
                p.vy += 0.05;
                
                if (p === currentParticle && !isDragging) {
                    p.vx += (mouseX - p.x) * 0.3;
                    p.vy += (mouseY - p.y) * 0.3;
                    p.size = lerp(p.size, 18, 0.15);
                } else {
                    p.size = lerp(p.size, 10, 0.08);
                    
                    if (currentParticle) {
                        let d = dist(p.x, p.y, currentParticle.x, currentParticle.y);
                        let radius = gridSpacing * (3 + intensity * 4);
                        if (d < radius && d > 0) {
                            let force = (1 - d / radius) * (0.8 + intensity * 2);
                            let angle = atan2(p.y - currentParticle.y, p.x - currentParticle.x);
                            p.vx += cos(angle) * force * 1.2;
                            p.vy += sin(angle) * force * 1.2;
                        }
                    }
                }
                
                for (let other of particles) {
                    if (other === p) continue;
                    let d = dist(p.x, p.y, other.x, other.y);
                    if (d < gridSpacing * 0.6 && d > 0) {
                        let force = (gridSpacing * 0.6 - d) / (gridSpacing * 0.6);
                        let angle = atan2(p.y - other.y, p.x - other.x);
                        p.vx += cos(angle) * force * 0.3;
                        p.vy += sin(angle) * force * 0.3;
                    }
                }
                
                p.vx += (noise(p.x * 0.01, frameCount * 0.01) - 0.5) * 0.05;
                p.vy += (noise(p.y * 0.01, frameCount * 0.01 + 100) - 0.5) * 0.05;
                
                p.vx *= 0.94;
                p.vy *= 0.94;
                
                let vel = sqrt(p.vx * p.vx + p.vy * p.vy);
                if (vel > 8) {
                    p.vx = (p.vx / vel) * 8;
                    p.vy = (p.vy / vel) * 8;
                }
                
                p.x += p.vx;
                p.y += p.vy;
                
                if (p.x < 0) { p.x = 0; p.vx *= -0.5; }
                if (p.x > width) { p.x = width; p.vx *= -0.5; }
                if (p.y > height) { p.y = height; p.vy *= -0.5; }
            }
            
            for (let iter = 0; iter < 5; iter++) {
                for (let c of connections) {
                    if (!c.active) continue;
                    
                    let dx = c.p2.x - c.p1.x;
                    let dy = c.p2.y - c.p1.y;
                    let d = sqrt(dx * dx + dy * dy);
                    
                    if (d > c.length * 3.0) {
                        c.active = false;
                        let midX = (c.p1.x + c.p2.x) / 2;
                        let midY = (c.p1.y + c.p2.y) / 2;
                        playTearSound(0.7, midX, midY);
                        continue;
                    }
                    
                    if (d < 0.1) continue;
                    
                    let diff = (d - c.length) / d;
                    let ox = dx * diff * 0.5;
                    let oy = dy * diff * 0.5;
                    
                    if (!c.p1.pinned) {
                        c.p1.x += ox;
                        c.p1.y += oy;
                    }
                    if (!c.p2.pinned) {
                        c.p2.x -= ox;
                        c.p2.y -= oy;
                    }
                }
            }
            
            let totalStrain = 0;
            let activeCount = 0;
            for (let c of connections) {
                if (c.active) {
                    let d = dist(c.p1.x, c.p1.y, c.p2.x, c.p2.y);
                    totalStrain += d / c.length;
                    activeCount++;
                }
            }
            let avgStrain = activeCount > 0 ? totalStrain / activeCount : 1;
            
            updateAudio(avgStrain, intensity, hasMovement);
            
            for (let c of connections) {
                if (!c.active) continue;
                
                let d = dist(c.p1.x, c.p1.y, c.p2.x, c.p2.y);
                let strain = d / c.length;
                
                let r = 150, g = 150, b = 150;
                if (strain > 1.5) {
                    r = 255;
                    g = 100;
                    b = 100;
                }
                
                let alpha = map(d, 0, gridSpacing * 2, 80, 15);
                let thickness = map(d, 0, gridSpacing * 2, 2.5, 0.5);
                
                stroke(r, g, b, alpha);
                strokeWeight(thickness);
                line(c.p1.x, c.p1.y, c.p2.x, c.p2.y);
            }
            
            for (let p of particles) {
                noStroke();
                
                // Current particle is RED
                if (p === currentParticle) {
                    fill(255, 50, 50);
                } else {
                    fill(255, 200, 200);
                }
                
                circle(p.x, p.y, p.size);
            }
        }

        function lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            let denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (abs(denom) < 0.001) return false;
            let t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            let u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
            return (t >= 0 && t <= 1 && u >= 0 && u <= 1);
        }

        function keyPressed() {
            if (key === '+' || key === '=') {
                gridSpacing = constrain(gridSpacing - 10, 20, 150);
                createGrid();
                currentParticle = null;
            } else if (key === '-' || key === '_') {
                gridSpacing = constrain(gridSpacing + 10, 20, 150);
                createGrid();
                currentParticle = null;
            } else if (key === 'r' || key === 'R') {
                createGrid();
                currentParticle = null;
            } else if (key === 's' || key === 'S') {
                soundEnabled = !soundEnabled;
                document.getElementById('soundStatus').textContent = soundEnabled ? 'ON' : 'OFF';
                document.getElementById('soundStatus').style.color = soundEnabled ? '#4a4' : '#a44';
            }
        }

        async function mousePressed() {
            if (!audioInitialized) {
                console.log("üñ±Ô∏è Mouse pressed - initializing audio...");
                await initAudio();
            }
            isDragging = true;
        }
        
        async function mouseMoved() {
            if (!audioInitialized) {
                console.log("üñ±Ô∏è Mouse moved - initializing audio...");
                await initAudio();
            }
        }

        function mouseReleased() {
            isDragging = false;
        }

        // MOBILE TOUCH SUPPORT WITH GESTURES
        async function touchStarted() {
            console.log("üëÜ Touch detected, fingers:", touches.length);

            // Triple-tap detection
            let now = millis();
            if (now - lastTapTime < 300) {
                tapCount++;
                if (tapCount >= 2) { // 3 taps total
                    // Reset grid on triple tap
                    createGrid();
                    currentParticle = null;
                    tapCount = 0;
                    console.log("üëÜüëÜüëÜ Triple tap - Reset!");
                    return false;
                }
            } else {
                tapCount = 0;
            }
            lastTapTime = now;
            
            // Clear tap timeout
            if (tapTimeout) clearTimeout(tapTimeout);
            tapTimeout = setTimeout(() => { tapCount = 0; }, 400);
            
            // Check for pinch gesture (2 fingers)
            if (touches.length === 2) {
                let d = dist(touches[0].x, touches[0].y, touches[1].x, touches[1].y);
                lastTouchDist = d;
                // 2 fingers = tearing mode
                isDragging = true;
                console.log("‚úåÔ∏è Two fingers - tear mode enabled");
                return false;
            }
            
            // Single touch - ONLY HOVERING (no tearing!)
            if (touches.length === 1) {
                isDragging = false; // Important: 1 finger does NOT tear!
                console.log("üëÜ One finger - hover mode");
            }
            
            return false; // Prevent default
        }
        
        function touchMoved() {
            // Pinch-to-zoom gesture (2 fingers)
            if (touches.length === 2) {
                let d = dist(touches[0].x, touches[0].y, touches[1].x, touches[1].y);
                
                if (lastTouchDist > 0) {
                    let delta = d - lastTouchDist;
                    
                    // Pinch in (together) ‚Üí denser grid
                    // Pinch out (apart) ‚Üí looser grid
                    if (abs(delta) > 2) { // Threshold to avoid jitter
                        gridSpacing = constrain(gridSpacing - delta * 0.2, 20, 150);
                        createGrid();
                        currentParticle = null;
                        document.getElementById('gridInfo').textContent = gridSpacing.toFixed(0) + 'px';
                        const mobileInfo = document.getElementById('gridInfoMobile');
                        if (mobileInfo) mobileInfo.textContent = gridSpacing.toFixed(0) + 'px';
                    }
                }
                
                lastTouchDist = d;
                
                // 2 fingers = can tear
                isDragging = true;
                return false;
            }
            
            // 1 finger = only hover, no tearing
            if (touches.length === 1) {
                isDragging = false;
            }
            
            return false; // Prevent scrolling
        }

        function touchEnded() {
            isDragging = false;
            
            // Reset pinch distance when fingers lift
            if (touches.length < 2) {
                lastTouchDist = 0;
            }
            
            return false;
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            createGrid();
            currentParticle = null;
        }
    </script>
</body>
</html>